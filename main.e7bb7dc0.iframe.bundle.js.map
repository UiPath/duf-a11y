{"version":3,"file":"main.e7bb7dc0.iframe.bundle.js","mappings":";;AAyKA;ACpKA;;ADuKA;AACA;AACA;;;AAGA;AEhLA;;AFmLA;AACA;AACA;;;;AGlLA;AASA;AAGA;ACdA;;AAcA;AAdA;;AAsBA;ACwFA;AACA;AACA;;AAIA;;;AA0CA;;AAEA;AACA;AAIA;AAaA;AACA;AACA;;AAKA;AAKA;AACA;AACA;;AAKA;AAiBA;AChNA;ADkNA;;;;AE7MA;AACA;AACA;;AAEA;AACA;;;ACLA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;ACHA;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;AACA;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;ACZA;;ACgCA;AACA;AAtBA;AASA;;;AAGA;;;;AAPA;AAmBA;AACA;;;;AAMA;AAKA;AACA;AAGA;;;AAGA;AACA;;;;AAMA;;AAEA;AACA;;;AC1CA;;AANA;;AAUA;;;ACjCA;;AAFA;AAKA;AADA;ACgCA;AACA;;AAEA;;ACXA;AAeA;AACA;AACA;;AAGA;;;ACbA;;AAEA;AACA;AACA;;;ACdA;AACA;AAEA;AACA;AACA;ACCA;AAYA;;AAEA;AACA;;;;;AAKA;AAOA;AAEA;;AAEA;AACA;;;;;AAKA;AAOA;AACA;;AAEA;;;AAGA;AACA;AACA;;AC/EA;;;ACWA;AACA;;;;ACgDA;AAGA;ACjEA;;ACqBA;;AAEA;AACA;AACA;AACA;AACA;;;;;ACiBA;AACA;;AC3CA;ADgDA;AACA;;AA0BA;;AAXA;;;AAGA;AACA;AACA;;;AAUA;AAOA;AACA;AACA;AACA;AAIA;;AEhFA;AACA;;AAEA;;AFuFA;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;;;AGzEA;AAEA;AAGA;ACoDA;ACmCA;AACA;AACA;AACA;AACA;;;AAKA;;ACxHA;;;AAGA;;AC1BA;;;;;;;;;;;ACaA;AF2CA;AACA;AACA;;;AAGA;;AASA;;;AE7BA;AACA;AACA;;AAEA;AAEA;AAQA;AACA;;AAEA;AACA;;AC3DA;AC0BA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;ACAA;;AAEA;AACA;;AAEA;AACA;;;;ACwCA;AC3EA;;;;;;;AASA;ALqDA;AACA;;;AAGA;;AMmEA;ACvGA;;AAEA;AACA;;;AAIA;;ADqGA;AAMA;;AAEA;;AAEA;AACA;AACA;;AAIA;AA2OA;;AAIA","sources":["webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/LineTooltip.ts","webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/constants/style.ts","webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/constants/class-names.ts","webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/util/createOrGetOverlay.ts","webpack://storybook/../lib/core/visualizations/charts/common/util/constructLegendContainer.ts","webpack://storybook/../lib/core/visualizations/charts/kpi/KpiChart.ts","webpack://storybook/../lib/core/visualizations/charts/kpi/constants/classNames.ts","webpack://storybook/../lib/core/plugins/legend/util/mapLegendItem.ts","webpack://storybook/../lib/core/plugins/legend/util/renderOrdinalLegend.ts","webpack://storybook/../lib/core/plugins/message-handler/internal/iconMapper.ts","webpack://storybook/../lib/core/plugins/message-handler/MessageHandler.ts","webpack://storybook/../lib/core/plugins/tabular-legend/TabularLegend.ts","webpack://storybook/../lib/core/visualizations/common/createTrendLabel.ts","webpack://storybook/../node_modules/@uipath/infinity/infinity.esm.js","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/AlignedLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/TextCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/Bar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TextTrendLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/ComponentWithLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/util/rowMinWidth.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/ZeroLine.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/StackedBar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/util/coercion/coerceBarCellData.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/GanttBar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/GanttChartBarCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/util/getGanttLines.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/GanttLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/SimpleBar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/SimpleBarCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/CompareBarCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/HeaderCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/sorting/SortIcon.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TableHeader.ts","webpack://storybook/../node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/ContentCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TableRow.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/row-renderers/GenericRowRenderer.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/util/scrollbarWidth.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/GenericTableRenderer.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TableFooter.ts"],"sourcesContent":["import './LineTooltip.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    assert,\n    getDataSetFromChart,\n    getValuesFromChart,\n} from '../../../common/util';\nimport { ChartInstance } from '../../../models';\nimport {\n    LegendRow,\n    TabularLegend,\n} from '../../tabular-legend';\nimport {\n    CHART_TOOLTIP_CURSOR_ID,\n    CHART_TOOLTIP_ID,\n    CHART_TOOLTIP_INITIAL_STYLE,\n    TEXT_BOTTOM_ID,\n    TEXT_TOP_ID,\n    TOOLTIP_LINE_CLASS,\n    TOOLTIP_TEXT_CLASS,\n    TOOLTIP_TEXT_STYLE,\n} from './constants';\nimport {\n    TooltipFormatter,\n    TooltipInfo,\n    TooltipModel,\n    TooltipProperties,\n    TooltipStructure,\n} from './models';\nimport {\n    CHART_OVERLAY_ID,\n    coerceFormatter,\n    createOrGetOverlay,\n    getTooltipArea,\n    setLabelTextStyle,\n    setTooltipPosition,\n    setTooltipStyle,\n} from './util';\n\nexport class LineTooltip<TMetaData> {\n    private _chart: ChartInstance<TMetaData>;\n    private _formatter: TooltipFormatter<TMetaData>;\n    private _container: HTMLDivElement | null;\n\n    private get _tooltip(): TooltipStructure {\n        return this._createOrGetTooltip();\n    }\n\n    constructor({\n        chart,\n        tooltipFormatter = {},\n    }: TooltipProperties<TMetaData>) {\n        this._formatter = coerceFormatter(tooltipFormatter) ?? this._getDefaultFormatter;\n\n        this._chart = chart;\n\n        this._container = this._chart.container;\n        this._container.addEventListener('mouseout', this.hide);\n    }\n\n    destroy() {\n        this._container?.removeEventListener('mouseout', this.hide);\n        document.getElementById(CHART_OVERLAY_ID)?.remove();\n    }\n\n    hide = () => {\n        this._tooltip.container.style.setProperty('opacity', '0');\n        this._tooltip.container.style.setProperty('height', '0px');\n        this._tooltip.container.style.setProperty('width', '0px');\n        this._tooltip.container.style.setProperty('display', 'none');\n    };\n\n    update(\n        model: TooltipModel,\n    ) {\n        const tooltipArea = getTooltipArea(this._chart);\n\n        setTooltipStyle(this._tooltip.container, tooltipArea, model);\n\n        const index = model.dataIndex;\n\n        const values = getValuesFromChart(this._chart, index);\n\n        assert(values.length > 0, 'Expected the tooltip to have data points and colors.');\n\n        const dataset = getDataSetFromChart(this._chart);\n        const source = this._formatter({\n            colors: values.map(({ color }) => color),\n            data: values.map(({ value }) => value),\n            meta: dataset.meta?.[index],\n        });\n\n        this._applyLabel(this._tooltip.topText, source.yLabel);\n        this._applyLabel(this._tooltip.bottomText, source.xLabel);\n\n        setTooltipPosition(this._tooltip.container, tooltipArea, model);\n\n        this._setCursorHeight();\n        this._setBottomTextVisibility();\n\n        setLabelTextStyle(this._tooltip.bottomText, tooltipArea);\n        setLabelTextStyle(this._tooltip.topText, tooltipArea);\n    }\n\n    private _applyLabel(element: HTMLDivElement, legendSchema: LegendRow[] = []) {\n        if (legendSchema.length > 0) {\n            element.style.visibility = 'visible';\n            element.innerHTML = '';\n            element.appendChild(TabularLegend(legendSchema));\n        } else {\n            element.style.visibility = 'hidden';\n        }\n    }\n\n    private _tooltipCells(value: Date | string | number, color: string = ''): LegendRow {\n        return {\n            cells: [ {\n                text: value.toLocaleString(),\n                color,\n            } ],\n        };\n    }\n\n    private _getDefaultFormatterMulti({\n        data,\n        colors,\n    }: TooltipInfo<TMetaData>) {\n        const hasSameXValues = data.every(({ x }) => x === data[0].x);\n\n        return {\n            xLabel: hasSameXValues\n                ? [ this._tooltipCells(data[0].x) ]\n                : data.map(({ x }, index) => this._tooltipCells(x, colors[index])),\n            yLabel: data.map(({ y }, index) => this._tooltipCells(y, colors[index])),\n        };\n    }\n\n    private _getDefaultFormatterSingle({ data }: TooltipInfo<TMetaData>) {\n        return {\n            xLabel: data.map(({ x }) => this._tooltipCells(x)),\n            yLabel: data.map(({ y }) => this._tooltipCells(y)),\n        };\n    }\n\n    private _getDefaultFormatter(info: TooltipInfo<TMetaData>) {\n        return info.data.length > 1\n            ? this._getDefaultFormatterMulti(info)\n            : this._getDefaultFormatterSingle(info);\n    }\n\n    private _getStructure(container: HTMLDivElement) {\n        return {\n            container,\n            cursor: document.getElementById(CHART_TOOLTIP_CURSOR_ID) as HTMLDivElement,\n            topText: document.getElementById(TEXT_TOP_ID) as HTMLDivElement,\n            bottomText: document.getElementById(TEXT_BOTTOM_ID) as HTMLDivElement,\n        };\n    }\n\n    private _createOrGetTooltip() {\n        let container = document.getElementById(CHART_TOOLTIP_ID) as HTMLDivElement;\n\n        if (container) {\n            return this._getStructure(container);\n        }\n\n        container = html`\n            <div id=\"${CHART_TOOLTIP_ID}\"\n                style=\"${CHART_TOOLTIP_INITIAL_STYLE}\">\n\n                <div id=\"${TEXT_TOP_ID}\"\n                    class=\"${TOOLTIP_TEXT_CLASS}\"\n                    style=\"${TOOLTIP_TEXT_STYLE}\">\n                </div>\n\n                <div id=\"${CHART_TOOLTIP_CURSOR_ID}\"\n                    class=\"${TOOLTIP_LINE_CLASS}\"></div>\n\n                <div id=\"${TEXT_BOTTOM_ID}\"\n                    class=\"${TOOLTIP_TEXT_CLASS}\"\n                    style=\"${TOOLTIP_TEXT_STYLE}\">\n                </div>\n\n            </div>\n        ` as HTMLDivElement;\n\n        createOrGetOverlay()\n            .appendChild(container);\n\n        return this._getStructure(container);\n    }\n\n    private _setCursorHeight() {\n        const cursorRect = this._tooltip.cursor.getBoundingClientRect();\n\n        this._tooltip.cursor.style.height = cursorRect.bottom > document.documentElement.clientHeight\n            ? `${document.documentElement.clientHeight - cursorRect.top}px` : '';\n    }\n\n    private _setBottomTextVisibility() {\n        const bottomY = this._tooltip.bottomText.getBoundingClientRect().bottom;\n\n        this._tooltip.bottomText.style.display = bottomY > document.documentElement.clientHeight\n            ? 'none' : '';\n    }\n}\n","export const TOOLTIP_TEXT_STYLE = `\n    padding: 5px;\n    height: auto;\n`;\n\nexport const CHART_TOOLTIP_INITIAL_STYLE = 'display: none;';\n","export const TOOLTIP_TEXT_CLASS = 'chart-tooltip-text';\nexport const TOOLTIP_LINE_CLASS = 'chart-tooltip-line';\n","import html from 'nanohtml';\n\nexport const CHART_OVERLAY_ID = 'chart-overlay-container';\n\nexport const createOrGetOverlay = () => {\n    let overlay = document\n        .getElementById(CHART_OVERLAY_ID);\n\n    if (overlay) {\n        return overlay;\n    }\n\n    overlay = html`\n        <div id=${CHART_OVERLAY_ID}></div>\n    `;\n\n    document.body.append(overlay);\n\n    return overlay;\n};\n","import html from 'nanohtml';\n\nconst LEGEND_HEIGHT = 32;\n\nconst createLegendContainer = () => html`\n        <div style=\"width: 100%; height: ${LEGEND_HEIGHT}px;\">\n        </div>\n    `;\n\nconst createSiblingContainer = () => html`\n        <div style=\"width: 100%; height: calc(100% - ${LEGEND_HEIGHT}px)\">\n        </div>\n    ` as HTMLDivElement;\n\nexport const constructLegendContainer = (container: HTMLDivElement) => {\n    const legendContainer = createLegendContainer();\n    const siblingContainer = createSiblingContainer();\n\n    container.childNodes.forEach((child) => siblingContainer.appendChild(child));\n    container.innerHTML = '';\n\n    container.appendChild(legendContainer);\n    container.appendChild(siblingContainer);\n\n    return legendContainer;\n};\n","import './KpiChart.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\nimport tippy, { Instance } from 'tippy.js';\n\nimport {\n    BLUE,\n    ORANGE,\n} from '../../../common/constants';\nimport { DEFAULT_TIPPY_PROPERTIES } from '../../../common/constants/defaultTippyProperties';\nimport { createTrendLabel } from '../../common/createTrendLabel';\nimport { Chart } from '../chart';\nimport { LineChart } from '../line/LineChart';\nimport {\n    KPI,\n    KPI_CHART,\n    KPI_COMPARE_WRAPPER,\n    KPI_CONTENT_COMPARE,\n    KPI_CONTENT_WRAPPER,\n    KPI_NO_DATA,\n    KPI_SMALL_SIZE,\n    KPI_SUBTITLE,\n    KPI_TITLE,\n    KPI_VALUE,\n    KPI_WRAPPER_TEXT,\n    KPI_WRAPPER_TEXT_LINE,\n} from './constants';\nimport {\n    KpiChartProps,\n    KpiContent,\n    KpiTextData,\n} from './models';\n\nexport class KpiChart<TMetaData = unknown> {\n\n    readonly chart: LineChart<TMetaData> | Chart | null = null;\n    private _textWrapper: HTMLElement;\n    private _chartElement: HTMLDivElement | null = null;\n    private _tooltip: Instance;\n    private _container: HTMLElement;\n\n    constructor({\n        textData,\n        container,\n        chartData,\n        size = 'default',\n    }: KpiChartProps<TMetaData>) {\n\n        if (chartData) {\n            const {\n                alt,\n                data,\n                compareData,\n                labels,\n                tooltipFormatter,\n                meta,\n                color,\n                compareColor,\n            } = chartData;\n\n            this._chartElement = document.createElement('div');\n            this._chartElement.classList.add(KPI_CHART);\n\n            const commonChartProperties = {\n                container: this._chartElement,\n                scaleY: { display: false },\n                scaleX: { display: false },\n                alt,\n                labels,\n            };\n\n            if (compareData) {\n                this.chart = new Chart({\n                    ...commonChartProperties,\n                    data: [ {\n                        data,\n                        renderer: 'line',\n                        color: color ?? BLUE,\n                    }, {\n                        data: compareData,\n                        renderer: 'line',\n                        color: compareColor ?? ORANGE,\n                    } ],\n                });\n            } else {\n                this.chart = new LineChart<TMetaData>({\n                    ...commonChartProperties,\n                    data,\n                    color: () => color ?? BLUE,\n                    meta,\n                    tooltipFormatter,\n                });\n            }\n        }\n\n        this._textWrapper = this._createText(textData);\n\n        const titleElement = html`<p tabindex=\"0\" class=\"${KPI_TITLE}\">${textData.title}</p>`;\n        this._textWrapper.prepend(titleElement);\n\n        const hasChartData = chartData?.data !== undefined && chartData.data.length > 0;\n        const hasKpiData = textData.content.length > 0;\n        const hasData = hasChartData || hasKpiData;\n\n        const kpiClass = clsx(\n            KPI,\n            size === 'small' && KPI_SMALL_SIZE,\n            !hasData && KPI_NO_DATA,\n        );\n\n        this._container = html `\n            <div class=\"${kpiClass}\">\n                ${this._textWrapper}\n                ${this._chartElement}\n            </div>\n        `;\n\n        this._tooltip = tippy(titleElement, {\n            ...DEFAULT_TIPPY_PROPERTIES,\n            onShow: (instance) => instance.setContent(textData.title),\n        });\n\n        container.append(this._container);\n    }\n\n    destroy() {\n        this.chart?.destroy();\n        this._chartElement?.remove();\n        this._tooltip.destroy();\n\n        this._textWrapper.remove();\n        this._container.remove();\n    }\n\n    private _createContentElement({\n        value,\n        compareValue,\n        subtitle,\n        isCompareValuePositive,\n        comparison,\n    }: KpiContent, hasSingleContentElement: boolean) {\n        const subtitleElement = subtitle\n            ? html`<p class=\"${KPI_SUBTITLE}\">${subtitle}</p>`\n            : undefined;\n\n        const content = comparison === 'trend'\n            ? this._createTrendContentElement({\n                value,\n                compareValue,\n                isCompareValuePositive,\n            })\n            : this._createCompareContentElement({\n                value,\n                compareValue,\n            });\n\n        return html`\n            <div style=\"\n                width: fit-content;\n                padding-right: ${!hasSingleContentElement ? 40 : 0}px\n            \">\n                ${content}\n                ${subtitleElement}\n            </div>`;\n    }\n\n    private _createTrendContentElement({\n        value,\n        compareValue,\n        isCompareValuePositive,\n    }: KpiContent) {\n        const compareElement = compareValue\n            ? createTrendLabel({\n                compareValue,\n                isPositive: isCompareValuePositive ?? false,\n            })\n            : undefined;\n\n        return html`\n            <div class=\"${KPI_COMPARE_WRAPPER}\">\n                <p class=\"${KPI_VALUE}\">${value} </p>\n                ${compareElement}\n            </div>\n        `;\n    }\n\n    private _createCompareContentElement({\n        value,\n        compareValue,\n    }: KpiContent) {\n        return html`\n            <div class=\"${KPI_CONTENT_COMPARE}\">\n                <p class=\"${KPI_VALUE}\">${value}</p>\n                <p class=\"${KPI_VALUE}\">${compareValue}</p>\n            </div>\n        `;\n    }\n\n    private _createText({ content }: KpiTextData) {\n        const hasSingleContentElement = content.length === 1;\n        const contentElement = content.map(({\n            value,\n            compareValue,\n            subtitle,\n            isCompareValuePositive,\n            comparison = 'trend',\n        }) => this._createContentElement({\n            value,\n            compareValue,\n            subtitle,\n            isCompareValuePositive,\n            comparison,\n        }, hasSingleContentElement));\n\n        return html `\n            <div class=\"${this._chartElement ? KPI_WRAPPER_TEXT_LINE : KPI_WRAPPER_TEXT}\">\n                <div class=\"${KPI_CONTENT_WRAPPER}\">\n                    ${contentElement}\n                </div>\n            </div>\n        `;\n    }\n}\n","import { toClassSelector } from '../../../../common/util';\n\nexport const KPI = 'kpi';\nexport const KPI_SELECTOR = toClassSelector(KPI);\n\nexport const KPI_TITLE = 'kpi-title';\nexport const KPI_TITLE_SELECTOR = toClassSelector(KPI_TITLE);\n\nexport const KPI_CONTENT_WRAPPER = 'kpi-content-wrapper';\n\nexport const KPI_CONTENT_COMPARE = 'kpi-content-compare';\nexport const KPI_CONTENT_COMPARE_SELECTOR = toClassSelector(KPI_CONTENT_COMPARE);\n\nexport const KPI_VALUE = 'kpi-value';\nexport const KPI_VALUE_SELECTOR = toClassSelector(KPI_VALUE);\n\nexport const KPI_SUBTITLE = 'kpi-subtitle';\nexport const KPI_SUBTITLE_SELECTOR = toClassSelector(KPI_SUBTITLE);\n\nexport const KPI_WRAPPER_TEXT = 'kpi-wrapper-text';\nexport const KPI_WRAPPER_TEXT_SELECTOR = toClassSelector(KPI_WRAPPER_TEXT);\n\nexport const KPI_WRAPPER_TEXT_LINE = 'kpi-wrapper-text-line';\n\nexport const KPI_CHART = 'kpi-chart';\nexport const KPI_CHART_SELECTOR = toClassSelector(KPI_CHART);\n\nexport const KPI_COMPARE_WRAPPER = 'kpi-compare-wrapper';\nexport const KPI_COMPARE_WRAPPER_SELECTOR = toClassSelector(KPI_COMPARE_WRAPPER);\n\nexport const KPI_SMALL_SIZE = 'kpi-small';\nexport const KPI_NO_DATA = 'kpi-no-data';\n","import { tinycolor } from '@ctrl/tinycolor';\nimport html from 'nanohtml';\n\nimport {\n    DUF_LEGEND_COLOR,\n    DUF_LEGEND_ITEM,\n    DUF_LEGEND_LABEL,\n} from '../../../common/constants';\n\nexport const mapLegendItem = (label: string, color: string) => {\n    const itemColor = tinycolor(color).toRgbString();\n\n    return html`\n        <div class=\"${DUF_LEGEND_ITEM}\">\n            <div class=\"${DUF_LEGEND_COLOR}\"\n                style=\"background-color: ${itemColor};\">\n            </div>\n            <div class=\"${DUF_LEGEND_LABEL}\">\n                <label>${label}</label>\n            </div>\n        </div>\n    `;\n};\n","import html from 'nanohtml';\n\nimport { DUF_LEGEND_ITEM_CONTAINER } from '../../../common/constants';\nimport { assert } from '../../../common/util';\nimport { OrdinalLegendProps } from '../models';\nimport { mapLegendItem } from './mapLegendItem';\n\nexport const renderOrdinalLegend = ({\n    labels,\n    colors,\n}: OrdinalLegendProps) => {\n    assert(labels.length === colors.length, 'Expected an ordinal legend to have the same number of colors as labels.');\n\n    const legendItems = labels.map((label, index) =>\n        mapLegendItem(label, colors[index])\n    );\n\n    return html`\n        <div class=\"${DUF_LEGEND_ITEM_CONTAINER}\">\n            ${legendItems}\n        </div>\n    `;\n};\n","import { ComponentType } from '../constants';\nimport {\n    noBarDataIllustration,\n    noDataIllustration,\n    noGraphDataIllustration,\n    noHorizontalBarDataIllustration,\n    noLineDataIllustration,\n    noPieDataIllustration,\n    noTableDataIllustration,\n} from '../illustrations';\nimport { MessageStatus } from '../models/MessageStatus';\n\nexport const iconMapper = (status?: MessageStatus, componentType?: ComponentType) => {\n    if (status === MessageStatus.NoData) {\n        switch (componentType) {\n            case ComponentType.LineChart: return noLineDataIllustration();\n            case ComponentType.BarChart: return noBarDataIllustration();\n            case ComponentType.HorizontalBarChart: return noHorizontalBarDataIllustration();\n            case ComponentType.PieChart: return noPieDataIllustration();\n            case ComponentType.Table: return noTableDataIllustration();\n            case ComponentType.ProcessGraph: return noGraphDataIllustration();\n            default: return noDataIllustration();\n        }\n    }\n\n    return undefined;\n};\n","import { ComponentType } from './constants';\nimport {\n    createMessageHandlerElement,\n    MessageHandlerInstance,\n} from './internal/createMessageHandlerElement';\nimport { iconMapper } from './internal/iconMapper';\nimport { MessageMapper } from './models/MessageMapper';\nimport { MessageStatus } from './models/MessageStatus';\n\nexport class MessageHandler {\n    private _messageMapper?: MessageMapper;\n    private _messageElement: MessageHandlerInstance;\n    private _sibling: {\n        element: HTMLElement;\n        initialDisplay: string;\n    };\n\n    constructor(container: HTMLElement, messageMapper?: MessageMapper) {\n        this._sibling = {\n            element: container,\n            initialDisplay: container.style.display,\n        };\n\n        this._messageMapper = messageMapper;\n        this._messageElement = createMessageHandlerElement(container, messageMapper !== undefined);\n    }\n\n    update(messageStatus?: MessageStatus, componentType?: ComponentType) {\n        const isMessageDisplayed = messageStatus !== undefined;\n        const {\n            textContainer,\n            iconContainer,\n        } = this._messageElement;\n\n        if (this._messageMapper !== undefined && isMessageDisplayed && textContainer) {\n            textContainer.textContent = this._messageMapper(messageStatus);\n        }\n\n        const statusIcon = iconMapper(messageStatus, componentType);\n        statusIcon?.setAttribute('role', 'img');\n        statusIcon?.setAttribute('aria-label', textContainer?.textContent ?? '');\n\n        const iconElements = statusIcon ? [ statusIcon ] : [];\n        iconContainer.replaceChildren(...iconElements);\n\n        this._messageElement.container.style.setProperty('display', isMessageDisplayed ? '' : 'none');\n        this._sibling.element.style.setProperty('display', isMessageDisplayed ? 'none' : this._sibling.initialDisplay);\n    }\n\n    destroy() {\n        this._messageElement.container.remove();\n        this._sibling.element.style.setProperty('display', this._sibling.initialDisplay);\n    }\n}\n","import './TabularLegend.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport { GTR_LEGEND_CONTENT } from '../../common/constants';\n\nexport type LegendCell = {\n    text: string;\n    color?: string;\n    colorClass?: string;\n    align?: 'right' | 'left';\n    role?: 'primary' | 'secondary';\n};\n\nexport type LegendRow = {\n    isSeparated?: boolean;\n    cells: LegendCell[];\n};\n\nconst mapColor = (cell: LegendCell) => {\n    const hasSpecificColor = cell.color !== undefined;\n    const hasColorClass = cell.colorClass !== undefined;\n\n    if (!hasSpecificColor && !hasColorClass) {\n        return '';\n    }\n\n    return html`\n        <div class=\"${clsx('block', cell.colorClass)}\"\n            style=\"\n                outline: 1px inset rgba(0, 0, 0, 0.1);\n                ${!hasColorClass ? `background-color: ${cell.color};` : ''}\n                display: inline-block'};\n            \">\n        </div>\n    `;\n};\n\nconst mapLegendCell = (cell: LegendCell) => html`\n        <td>\n            <div class=\"${GTR_LEGEND_CONTENT}\"\n                style=\"justify-content: ${cell.align === 'right' ? 'flex-end' : 'flex-start'}\">\n                ${mapColor(cell)}\n                <label class=\"${cell.role ?? 'primary'}\">\n                        ${cell.text}\n                </label>\n            </div>\n        </td>\n    `;\n\nexport const TabularLegend = (rows: LegendRow[], title?: string) => {\n    const tableContent = rows.map(({\n        cells,\n        isSeparated,\n    }) => html`\n        <tr class=\"${clsx(isSeparated && 'row-separator')}\">\n            ${cells.map((cell) => mapLegendCell(cell))}\n        </tr>`);\n\n    const tableHeader = title && html`\n        <tr>\n            <td colspan=\"2\">\n                <div class=\"${GTR_LEGEND_CONTENT}\">\n                    ${title}\n                </div>\n            </td>\n        </tr>\n    `;\n\n    return html`\n        <table class=\"cr-tabular-legend\">\n            ${ tableHeader }\n            ${ tableContent }\n        </table>\n    `;\n};\n","import './TrendLabel.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    TRENDING_DOWN,\n    TRENDING_UP,\n} from '../../common/constants/svgPaths';\nimport {\n    createSVGIcon,\n    SVG_ICON_S,\n} from '../../common/util/createSVGIcon';\nimport {\n    TREND_LABEL_WRAPPER,\n    TREND_NEGATIVE,\n    TREND_POSITIVE,\n} from './constants';\nimport { Trend } from './models/Trend';\n\nexport function createTrendLabel(trend: Trend) {\n    const {\n        isPositive,\n        compareValue,\n    } = trend;\n\n    const getTrendIcon = (): SVGSVGElement => createSVGIcon({\n        path: isPositive ? TRENDING_UP : TRENDING_DOWN,\n        size: SVG_ICON_S,\n    });\n\n    return html`\n    <div class=\"${isPositive ? TREND_POSITIVE : TREND_NEGATIVE} ${TREND_LABEL_WRAPPER}\">\n        <div style='display: flex; align-items: center'>\n            ${getTrendIcon()}\n        </div>\n        ${compareValue}\n    </div>`;\n}\n","import t from\"nanohtml\";import{Subject as e,defer as i}from\"rxjs\";import{takeUntil as s,debounceTime as r}from\"rxjs/operators\";import n from\"morphdom\";const h=t=>{const e=document.createElement(\"div\");e.style.position=\"absolute\",e.style.left=\"9999999999999999px\",e.style.top=\"9999999999999999px\";const{left:i,top:s}=(t=>{document.body.appendChild(t);const e=t.getBoundingClientRect();return document.body.removeChild(t),e})(e);return Math.abs(\"horizontal\"===t?i:s)},a=t=>`${t}px`,o=[\"infinity-item\"];class c{constructor(t){this._virtualSize=NaN,this._viewportSize=NaN,this._currentPage=0,this._pageOffset=0,this._scrollTop=0,this._pageCount=NaN,this._pageSize=NaN,this._jumpRatio=NaN,this._maxSize=h(t.direction),this._pageSize=Math.floor(this._maxSize/100),this.set(t)}get virtualScrollDistance(){return this._pageOffset+this._scrollTop}get scrollDistance(){return this._scrollTop}get pageOffset(){return this._pageOffset}get viewportSize(){return this._viewportSize}get virtualSize(){return this._virtualSize}set({viewportSize:t,virtualSize:e,scrollDistance:i}){this._virtualSize=null!=e?e:this._virtualSize,this._viewportSize=null!=t?t:this._viewportSize,this._pageCount=Math.ceil(this._virtualSize/this._pageSize);const s=(this._virtualSize-this._maxSize)/(this._pageCount-1);this._jumpRatio=s>0?s:1;if(Math.abs(i-this._scrollTop)>this._viewportSize){const t=(this._virtualSize-this._viewportSize)/(this._maxSize-this._viewportSize);this._currentPage=Math.floor(i*t*(1/this._pageSize)),this._scrollTop=i}else{const t=i+this._pageOffset,e=(this._currentPage+1)*this._pageSize,s=t<this._currentPage*this._pageSize;t>e?(this._currentPage+=1,this._scrollTop=i-this._jumpRatio):s?(this._currentPage-=1,this._scrollTop=i+this._jumpRatio):this._scrollTop=i}this._pageOffset=Math.floor(this._currentPage*this._jumpRatio)}scrollTo(t){this._currentPage=Math.floor(t/this._pageSize),this._pageOffset=Math.floor(this._currentPage*this._jumpRatio),this._scrollTop=t-this._pageOffset}}class l{constructor(){this.refresh=()=>{this._refresh()},this._refresh=()=>{},this.afterItemMount=()=>{}}}class d{constructor({dataSource:t,debounce:n=50}){this._cache=new Map,this._pending=new Set,this._emitter$=new e,this._query$=new e,this._destroyed$=new e,this._queryRange=t=>{this._markRangeAsPending(t),i((()=>this._dataSource(t))).pipe(s(this._destroyed$)).subscribe((e=>this._handleResponse(e,t)))},this._dataSource=t,this.change$=this._emitter$.asObservable(),this._query$.pipe(r(n),s(this._destroyed$)).subscribe(this._queryRange)}get isEmpty(){return 0===this._cache.size}get isPending(){return 0===this._pending.size}getRange(t){const{end:e}=t,i=this._determineLoadStartIndex(t);return null!=i&&this._query$.next({start:i,end:e}),this._getRangeData(t)}isCached(t){return this._cache.has(t)}isLoading(t){return this._pending.has(t)}dataOf(t){return this._cache.get(t)}clear(){this._cache.clear(),this._pending.clear()}destroy(){this.clear(),this._emitter$.complete(),this._destroyed$.next()}get size(){return this._cache.size}_handleResponse(t,e){const i=e.end-e.start;if(t.length!==i)throw Error(`Data source ${t.length} records, this chunk was supposed to return ${i}.`);const{start:s}=e;t.forEach(((t,e)=>{this._cache.set(e+s,t),this._pending.delete(e)})),this._emitter$.next(e)}_getRangeData({start:t,end:e}){const i=[];for(let s=t;s<e;s++){const t=this.dataOf(s);i.push(t)}return i}_determineLoadStartIndex({start:t,end:e}){for(let i=t;i<e;i++)if(!this.isCached(i)&&!this._pending.has(i))return i;return null}_markRangeAsPending({start:t,end:e}){for(let i=t;i<e;i++)this._pending.add(i)}}class _ extends l{constructor({dataSource:t}){super(),this._visibleRange=null,this._destroyed$=new e,this.afterItemMount=({vIndex:t,index:e})=>{var i;const s=this._cache.dataOf(t);null!=s&&(null===(i=this._afterEntryAttached)||void 0===i||i.call(this,{entryIndex:e,virtualEntryIndex:t,data:s}))},this.render=({range:t})=>{this._visibleRange=t;return this._cache.getRange(t).map(((e,i)=>{const s=i+t.start;return null==e?this._renderPlaceholder(s):this._renderEntry({data:e,virtualEntryIndex:s,entryIndex:i})}))},this._onCacheChange=t=>{var e,i;null!=this._visibleRange&&(e=t,i=this._visibleRange,!(e.end<i.start||e.start>i.end))&&this.refresh()},this._cache=new d({dataSource:t}),this._cache.change$.pipe(s(this._destroyed$)).subscribe(this._onCacheChange)}destroy(){this._cache.destroy(),this._destroyed$.next()}clear(){this._cache.clear(),this._visibleRange=null}cachedData(t){return t.map((t=>this._cache.dataOf(t)))}}const p=(t,e)=>\"vertical\"===e?t.scrollTop:t.scrollLeft;class u{constructor(e,i){var s;this.viewport=e,this.options=i,this._previousRange=[Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],this.handleResize=()=>{this._state.viewportSize!==this.viewport.offsetHeight&&(this._state.set({viewportSize:this.viewport.offsetHeight,scrollDistance:p(this.viewport,this._direction)}),requestAnimationFrame((()=>this.render())))},this.handleScroll=()=>{this._state.set({scrollDistance:p(this.viewport,this._direction)}),this.scrollDistance=this._state.scrollDistance,requestAnimationFrame((()=>this.render()))},this.render=(t=!1)=>{const[e,i]=this.range,[s,r]=this._previousRange;if(s===e&&r===i&&!t)return;this._previousRange=[e,i];const h=e*this.itemSize-this._state.pageOffset,c=\"vertical\"===this._direction?\"top\":\"left\";this.content.style.setProperty(c,a(h));const l=document.createDocumentFragment(),d=[];this._renderer.render({range:{start:e,end:i},offset:e}).map(((t,i)=>(({item:t,index:e=-1,offset:i})=>{const s=e+i;return t.classList.add(...o),t.dataset.infinityId=`${s}`,t.style.transform=\"translateZ(1px)\",t})({item:t,index:i,offset:e}))).forEach(((t,s)=>{const r=s+e;if(l.appendChild(t),r>this.options.count-1)throw Error(`Your render implementation returned too many items. The range is exclusive: [${e}, ${i})`);d.push((()=>{var t,e;return null===(e=(t=this._renderer).afterItemMount)||void 0===e?void 0:e.call(t,{index:s,vIndex:r})}))})),n(this.content,l,{childrenOnly:!0}),d.forEach((t=>t()))},this.scrollToIndex=t=>{this._state.scrollTo(t*this.itemSize),this.scrollDistance=this._state.scrollDistance,this.render()},this._direction=null!==(s=i.direction)&&void 0!==s?s:\"vertical\",this._renderer=this.options.renderer,this._renderer._refresh=()=>this.render(!0);const r=this.options.count*this.itemSize;var l,d;this._state=new c({scrollDistance:p(this.viewport,this._direction),viewportSize:(l=this.viewport,d=this._direction,\"vertical\"===d?l.offsetHeight:l.offsetWidth),virtualSize:r,direction:this._direction}),this.scroller=(({virtualSize:e,direction:i})=>{const s=h(i),r=Math.min(s,e),n=\"vertical\"===i?`height: ${a(r)}`:`min-width: ${a(r)}`;return t`\n        <div class=\"infinity-scroller\"\n             style=\"${n}\">\n        </div>\n    `})({virtualSize:r,direction:this._direction}),this.content=((e=\"vertical\")=>t`\n    <div class=\"infinity-wrapper infinity-wrapper-${e}\"></div>\n`)(this._direction),this.scroller.appendChild(this.content),e.appendChild(this.scroller),this.viewport.addEventListener(\"scroll\",this.handleScroll),window.addEventListener(\"resize\",this.handleResize),this.handleScroll()}get itemSize(){return this._renderer.itemSize}set scrollDistance(t){\"vertical\"===this._direction?this.viewport.scrollTop=t:this.viewport.scrollLeft=t}get range(){const{virtualScrollDistance:t,viewportSize:e}=this._state,{overscan:i}=this.options;let s=Math.floor(t/this.itemSize),r=Math.floor(e/this.itemSize)+1;null!=i&&(s=Math.max(0,s-s%i),r+=i);return[s,Math.min(s+r,this.options.count)]}destroy(){this.viewport.removeEventListener(\"scroll\",this.handleScroll),window.removeEventListener(\"resize\",this.handleResize)}}export{_ as InfinityAsyncRenderer,u as InfinityList,c as InfinityListState,l as InfinityRenderer};\n","import './AlignedLabel.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_ALIGN_RIGHT_CLASS,\n    GTR_ALIGNED_LABEL_CLASS,\n    GTR_ALIGNED_WRAPPER_CLASS,\n    TextAlignment,\n} from '../../../common/constants';\nimport { createTrendLabel } from '../../common/createTrendLabel';\nimport { Trend } from '../../common/models/Trend';\n\ntype LabelProps = {\n    label: string;\n    align: TextAlignment;\n    trend?: Trend;\n};\n\nexport const AlignedLabel = ({\n    label,\n    align,\n    trend,\n}: LabelProps) => {\n    const isAlignedRight = align === 'right';\n    const wrapperClass = clsx(\n        GTR_ALIGNED_WRAPPER_CLASS,\n        isAlignedRight && GTR_ALIGN_RIGHT_CLASS\n    );\n\n    const labelClass = clsx(\n        GTR_ALIGNED_LABEL_CLASS,\n    );\n\n    return html`<div class=\"${wrapperClass}\">\n        <div class=\"${labelClass}\">\n            ${label}\n        </div>\n        ${trend && createTrendLabel(trend)}\n    </div>\n    `;\n};\n","import './TextCell.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_TEXT_CLASS,\n    TextAlignment,\n} from '../../../common/constants';\nimport { Trend } from '../../common/models/Trend';\nimport { AlignedLabel } from '../components/AlignedLabel';\nimport { RoleType } from '../models';\n\nexport type TextCellValue = string | number | Date | boolean | null;\nexport type TextCellData = {\n    value: TextCellValue;\n    label: string;\n    trend?: Trend;\n} | string;\n\ntype TextCellProps = {\n    data: TextCellData;\n    role?: RoleType;\n    style?: string;\n    className?: string;\n    align?: TextAlignment;\n};\n\nexport const TextCell = ({\n    data,\n    role = 'none',\n    align = 'left',\n    style = '',\n    className = '',\n}: TextCellProps) => {\n    const textCellClass = clsx(\n        GTR_TEXT_CLASS,\n        className\n    );\n    const label = typeof data === 'string' ? data : data.label;\n    const trend = typeof data === 'string' ? undefined : data.trend;\n\n    return html`\n        <div class=\"${textCellClass}\"\n             role=\"${role}\"\n             style=\"${style}\"\n        >\n            ${\n    AlignedLabel({\n        label,\n        align,\n        trend,\n    })\n}\n        </div>\n    ` as HTMLDivElement;\n};\n","import html from 'nanohtml';\n\nimport { BLUE } from '../../../common/constants';\n\ntype BarProps = {\n    value: number;\n    color?: string;\n    min: number;\n    max: number;\n    widthDenominator: number;\n    widthPositiveNumbers: number;\n    className: string;\n};\n\nexport const Bar = ({\n    value,\n    min,\n    max,\n    color = BLUE,\n    widthDenominator,\n    widthPositiveNumbers,\n    className,\n}: BarProps) => {\n    const isNegative = min < 0;\n\n    const barWidth = Math.abs(value) / widthDenominator * 100;\n    const supportDivWidth = (Math.abs(min) - Math.abs(value)) / widthDenominator * 100;\n\n    const supportBarWidth = value < 0\n        ? supportDivWidth\n        : widthPositiveNumbers;\n\n    const supportBarOffset = isNegative && max < 0 ? 1 : 0;\n\n    return html`\n            <div class=\"${className} ${value < 0 ? 'negative' : 'positive'}\"\n                style=\"\n                        width: ${barWidth}%;\n                        background-color: ${color ?? 'transparent'};\n                        margin-left:calc(${supportBarWidth}% - ${supportBarOffset}px);\n                \">\n            </div> ` as HTMLDivElement;\n};\n","import html from 'nanohtml';\n\nimport { createTrendLabel } from '../../common/createTrendLabel';\nimport { Trend } from '../../common/models/Trend';\n\ninterface TextTrendLabelProps {\n    trend?: Trend;\n    text: string;\n    trendLabelSide: 'left' | 'right';\n}\n\nexport const TextTrendLabel = ({\n    trend,\n    text,\n    trendLabelSide = 'right',\n}: TextTrendLabelProps) => {\n    const trendLabel = trend != null\n        ? createTrendLabel({\n            compareValue: trend.compareValue,\n            isPositive: trend.isPositive,\n        })\n        : undefined;\n\n    return (trendLabelSide === 'right'\n        ? html`<>\n            ${text}\n            ${trendLabel}\n        </>`\n        : html`<>\n            ${trendLabel}\n            ${text}\n        </>`) as HTMLDivElement;\n};\n","import './ComponentWithLabel.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_COMPONENT_LABEL_CLASS,\n    GTR_COMPONENT_WITH_LABEL_CLASS,\n} from '../../../common/constants/class-names';\nimport { Trend } from '../../common/models/Trend';\nimport { TextTrendLabel } from './TextTrendLabel';\n\nexport type LabelData = {\n    text: string;\n    size: number;\n    trend?: Trend;\n};\n\nexport interface Labels {\n    left?: LabelData;\n    right?: LabelData;\n}\n\nexport type ComponentWithLabelProps = {\n    component: HTMLElement;\n    labels: Labels;\n    contentWidth: number;\n    position: 'left' | 'right';\n    isAllPositive: boolean;\n    centerComponent?: boolean;\n};\n\nexport const ComponentWithLabel = ({\n    component,\n    contentWidth,\n    position,\n    centerComponent,\n    isAllPositive,\n    labels,\n}: ComponentWithLabelProps) => {\n    const startPercentage = isAllPositive ? 0 : 50;\n\n    const leftLabelWidth = `calc(${position === 'left' ? contentWidth : startPercentage}% + ${labels.left?.size}px)`;\n    const leftLabelElement = labels.left && html`\n    <label class=\"${GTR_COMPONENT_LABEL_CLASS}\"\n           style=\"\n                left: -${labels.left.size}px;\n                width:  ${leftLabelWidth};\n                justify-content: flex-end;\n                padding-right: 8px;\n           \"\n    >\n        ${TextTrendLabel({\n        trend: labels.left.trend,\n        text: labels.left.text,\n        trendLabelSide: 'left',\n    })}\n    </label>`;\n\n    const rightLabelWidth = `calc(${position === 'left' ? startPercentage : 100 - contentWidth }% + ${labels.right?.size}px)`;\n    const rightLabelElement = labels.right && html`\n    <label class=\"${GTR_COMPONENT_LABEL_CLASS}\"\n        style=\"\n                left: ${position === 'left' ? startPercentage : contentWidth}%;\n                width: ${rightLabelWidth};\n                justify-content: flex-start;\n                padding-right: 0px;\n        \"\n    >\n    ${TextTrendLabel({\n        trend: labels.right.trend,\n        text: labels.right.text,\n        trendLabelSide: 'right',\n    })}\n    </label>`;\n\n    return html`\n        <div class=\"${GTR_COMPONENT_WITH_LABEL_CLASS}\"\n            style=\"\n                margin: ${centerComponent ? '0 auto' : 'initial'}\n            \"\n        >\n            ${component}\n            ${leftLabelElement}\n            ${rightLabelElement}\n        </div>\n    ` as HTMLDivElement;\n};\n","import sum from 'lodash-es/sum';\n\nimport { ColumnCommon } from '../models';\n\nexport const rowMinWidth = (columns: ColumnCommon[]) =>\n    sum(columns.map(c => c.minWidth ?? 0));\n","import './ZeroLine.scss';\n\nimport html from 'nanohtml';\n\ntype ZeroLineProps = {\n    left: string;\n    display: boolean;\n};\n\nexport const ZeroLine = ({\n    display,\n    left,\n}: ZeroLineProps) => html`\n    <div class=\"gtr-zero-line\"\n            style=\"\n            left: ${left};\n            display: ${display ? 'block' : 'none'};\n        \">\n    </div>\n`;\n","import './StackedBar.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    BLUE,\n    GTR_BAR_CLASS,\n    GTR_STACKED_BAR_CLASS,\n} from '../../../common/constants';\nimport {\n    computeLeftZeroLine,\n    computeWidthDenominator,\n    computeWidthPositiveNumbers,\n} from '../renderers/common';\nimport { ZeroLine } from '../renderers/ZeroLine';\nimport { clampedSum } from '../util/clampedSum';\nimport { Bar } from './Bar';\n\ntype StackedBarProps = {\n    bars: number[];\n    max: number;\n    color: (index: number) => string;\n    min: number;\n    className?: string;\n};\n\nexport const StackedBar = ({\n    bars,\n    max,\n    min,\n    color = () => BLUE,\n    className = '',\n}: StackedBarProps) => {\n\n    const totalWidth = clampedSum(bars, max);\n    if (totalWidth > max) {\n        throw Error(`A stacked bar should sum up to at most ${ max }, but a total of ${totalWidth} was found.`);\n    }\n\n    const widthDenominator = computeWidthDenominator({\n        min,\n        max,\n    });\n\n    const widthPositiveNumbers = computeWidthPositiveNumbers({\n        min,\n        widthDenominator,\n    });\n\n    const leftZeroLine = computeLeftZeroLine({\n        min,\n        max,\n        widthPositiveNumbers,\n    });\n\n    const isNegative = min < 0;\n    const zeroLine = ZeroLine({\n        left: `${leftZeroLine}%`,\n        display: isNegative,\n    });\n\n    return html`<div class=\"${clsx(GTR_STACKED_BAR_CLASS, className)}\">\n    ${\n    zeroLine\n}\n    ${\n    bars.map((value, index) => Bar({\n        value,\n        min,\n        max,\n        color: color(index),\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_BAR_CLASS,\n    }))\n}\n    </div>` as HTMLDivElement;\n};\n","import { BarCellData } from '../../renderers';\n\nexport function coerceBarCellData(data: BarCellData) {\n    return typeof data === 'number' ? {\n        value: data,\n        label: data.toFixed(2),\n    } : {\n        value: data.value,\n        label: data.label,\n    };\n}\n","import './GanttBar.scss';\n\nimport html from 'nanohtml';\n\nimport { GTR_GANTT_BAR_CLASS } from '../../../common/constants';\n\nexport type GanttBarProperties = {\n    start: number;\n    width: number;\n    height: number;\n    borderStyle?: string;\n    color: string;\n};\n\nexport function GanttBar({\n    start,\n    width,\n    height,\n    borderStyle,\n    color,\n}: GanttBarProperties) {\n    return html`\n        <div\n            class=\"${GTR_GANTT_BAR_CLASS}\"\n            style=\"\n                width: ${width}%;\n                margin-left: ${start}%;\n                height: ${height}px;\n                background-color: ${color};\n                ${borderStyle ?? ''}\n            \"\n        ></div>\n    `;\n}\n","import './GanttChartBarCell.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_GANTT_BAR_CELL_CLASS,\n    GTR_GANTT_BARS_CLASS,\n    GTR_GANTT_CLASS,\n    GTR_GANTT_FOCUS_CLASS,\n    GTR_GANTT_LINE_CLASS,\n    GTR_GANTT_LINES_CLASS,\n} from '../../../common/constants';\nimport {\n    GanttBar,\n    GanttBarProperties,\n} from '../components/GanttBar';\nimport {\n    GanttLabel,\n    GanttLabelProperties,\n} from '../components/GanttLabel';\nimport { getGanttLines } from '../util';\n\nexport type GanttChartBarCellData = {\n    start: Date;\n    end: Date;\n    nextStartDate: Date;\n    finalCheckDate?: Date;\n    label: string;\n};\n\ntype GanttChartBarCellProps = {\n    mainEvent: GanttBarProperties;\n    finalCheck?: GanttBarProperties;\n    label: GanttLabelProperties;\n    minDate: Date;\n    maxDate: Date;\n    labelOffset: number;\n};\n\nfunction GanttLines(\n    minDate: Date,\n    maxDate: Date,\n) {\n    const lines = getGanttLines(minDate, maxDate)\n        .map(({ marginLeft }) => html`\n            <div\n                class=\"${GTR_GANTT_LINE_CLASS}\"\n                style=\"margin-left: ${marginLeft}%\"\n            ></div>\n        `);\n\n    return html`\n        <div class=\"${GTR_GANTT_LINES_CLASS}\">\n            ${lines}\n        </div>\n    `;\n}\n\nfunction GanttFocusBar(\n    mainEvent: GanttBarProperties,\n    finalCheck?: GanttBarProperties,\n) {\n    const marginLeft = Math.min(mainEvent.start, finalCheck?.start ?? Number.POSITIVE_INFINITY);\n    const width = Math.max(mainEvent.width, finalCheck?.width ?? 0);\n    const height = Math.max(mainEvent.height, finalCheck?.height ?? 0);\n\n    return html`\n        <div\n            class=\"${GTR_GANTT_FOCUS_CLASS}\"\n            tabindex=\"0\"\n            style=\"\n                margin-left: ${marginLeft}%;\n                width: ${width}%;\n                height: ${height}px;\n            \"\n        ></div>\n    `;\n}\n\nfunction GanttBars(\n    mainEvent: GanttBarProperties,\n    finalCheck?: GanttBarProperties,\n) {\n    const focusBar = GanttFocusBar(mainEvent, finalCheck);\n    const mainEventBar = GanttBar(mainEvent);\n    const finalCheckBar = finalCheck\n        ? GanttBar(finalCheck)\n        : undefined;\n\n    return html`\n        <div class=\"${GTR_GANTT_BARS_CLASS}\">\n            ${finalCheckBar}\n            ${mainEventBar}\n            ${focusBar}\n    `;\n}\n\nexport function GanttChartBarCell({\n    mainEvent,\n    finalCheck,\n    label,\n    minDate,\n    maxDate,\n    labelOffset,\n}: GanttChartBarCellProps) {\n    const ganttChartLines = GanttLines(minDate, maxDate);\n    const ganttChartBars = GanttBars(mainEvent, finalCheck);\n    const ganttChartLabel = GanttLabel(label);\n\n    return html`\n        <div class=\"${GTR_GANTT_BAR_CELL_CLASS}\">\n            <div\n                class=\"${GTR_GANTT_CLASS}\"\n                style=\"width: calc(100% - ${labelOffset}px)\"\n            >\n                ${ganttChartLines}\n                ${ganttChartBars}\n                ${ganttChartLabel}\n            </div>\n        </div>\n    `;\n}\n","import { scaleTime } from 'd3';\n\nimport { mapDatesToPercentage } from './mapDatesToPercentage';\n\nexport function getGanttLines(min: Date, max: Date) {\n    const lines = scaleTime()\n        .domain([ min, max ])\n        .ticks(8)\n        .map(tickDate => ({\n            lineValue: scaleTime().tickFormat()(tickDate),\n            lineDate: tickDate,\n        }));\n\n    return lines.map(({\n        lineValue,\n        lineDate,\n    }) => ({\n        value: lineValue,\n        marginLeft: mapDatesToPercentage(min, max, min, lineDate),\n    }));\n}\n","import './GanttLabel.scss';\n\nimport html from 'nanohtml';\n\nimport { GTR_GANTT_LABEL_CLASS } from '../../../common/constants';\n\nexport type GanttLabelProperties = {\n    start: number;\n    label: string;\n};\n\nexport function GanttLabel({\n    start,\n    label,\n}: GanttLabelProperties) {\n    return html`\n        <label\n            class=\"${GTR_GANTT_LABEL_CLASS}\"\n            style=\"margin-left: ${start}%\"\n        >\n            ${label}\n        </label>\n    `;\n}\n","import './SimpleBar.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    BLUE,\n    GTR_BAR_CLASS,\n    GTR_SIMPLE_BAR_CELL_CLASS,\n    GTR_SIMPLE_BAR_CLASS,\n} from '../../../common/constants';\nimport { computeLeftZeroLine } from '../renderers/common';\nimport { ZeroLine } from '../renderers/ZeroLine';\nimport { Bar } from './Bar';\n\ntype SimpleBarProps = {\n    value: number;\n    color?: string;\n    min: number;\n    max: number;\n    widthDenominator: number;\n    widthPositiveNumbers: number;\n};\n\nexport const SimpleBar = ({\n    value,\n    min,\n    max,\n    color = BLUE,\n    widthDenominator,\n    widthPositiveNumbers,\n}: SimpleBarProps) => {\n    const leftZeroLine = computeLeftZeroLine({\n        min,\n        max,\n        widthPositiveNumbers,\n    });\n\n    const isNegative = min < 0;\n    const zeroLine = ZeroLine({\n        left: `${leftZeroLine}`,\n        display: isNegative,\n    });\n\n    return html`\n    <div class=\"${GTR_SIMPLE_BAR_CLASS} ${GTR_SIMPLE_BAR_CELL_CLASS}\">\n        ${\n    zeroLine\n}\n        ${\n    Bar({\n        value,\n        min,\n        max,\n        color,\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_BAR_CLASS,\n    })\n}\n    </div> ` as HTMLDivElement;\n};\n","import './SimpleBarCell.scss';\n\nimport sum from 'lodash-es/sum';\n\nimport {\n    BLUE,\n    LABEL_PADDING,\n} from '../../../common/constants';\nimport { Trend } from '../../common/models/Trend';\nimport { ComponentWithLabel } from '../components/ComponentWithLabel';\nimport { SimpleBar } from '../components/SimpleBar';\nimport { TrendBounds } from '../models/ColumnWithTrend';\nimport { getMaxLabelSize } from '../util';\nimport { coerceBarCellData } from '../util/coercion/coerceBarCellData';\nimport { getLabels } from '../util/getLabels';\nimport {\n    computeLabelCount,\n    computeLeftMargin,\n    computePercentageTotal,\n    computeWidthDenominator,\n    computeWidthPositiveNumbers,\n} from './common';\nimport { BarCellData } from './models';\n\ntype SimpleBarCellData = {\n    values: number[];\n    labels: string[];\n    barLabel?: string;\n    trend?: Trend;\n} | number[];\n\ntype SimpleBarCellProps = {\n    data: SimpleBarCellData;\n    color?: string;\n    max: BarCellData;\n    min: BarCellData;\n    type: string;\n    trendBounds?: TrendBounds;\n};\n\nexport const SimpleBarCell = ({\n    data,\n    max,\n    min,\n    color = BLUE,\n    type,\n    trendBounds,\n}: SimpleBarCellProps) => {\n    const {\n        values,\n        trend: trendData,\n    } = Array.isArray(data)\n        ? {\n            values: data,\n            trend: undefined,\n        }\n        : data;\n\n    const {\n        value: minValue,\n        label: minLabel,\n    } = coerceBarCellData(min);\n\n    const {\n        value: maxValue,\n        label: maxLabel,\n    } = coerceBarCellData(max);\n\n    if (values.length !== 1) {\n        throw new Error(`Expected a single value for the simple bar cell, but found ${values.length}`);\n    }\n\n    const value = values[0];\n    const textLabelSize = getMaxLabelSize(minLabel, maxLabel);\n    const trendLabelSize = trendBounds != null\n        ? getMaxLabelSize(trendBounds.min, trendBounds.max) + 14\n        : 0;\n\n    const isNegativeMin = minValue < 0;\n    const isNegativeMax = maxValue < 0;\n    const labelCount = computeLabelCount({\n        min: minValue,\n        max: maxValue,\n    });\n\n    const widthDenominator = computeWidthDenominator({\n        min: minValue,\n        max: maxValue,\n    });\n\n    const widthPositiveNumbers = computeWidthPositiveNumbers({\n        min: minValue,\n        widthDenominator,\n    });\n\n    const percentageTotal = computePercentageTotal({\n        min: minValue,\n        values,\n        widthDenominator,\n    });\n\n    const simpleBar = SimpleBar({\n        value,\n        min: minValue,\n        max: maxValue,\n        color,\n        widthDenominator,\n        widthPositiveNumbers,\n    });\n\n    const barLabel = 'barLabel' in data ? data.barLabel : null;\n\n    if (barLabel == null) {\n        return simpleBar;\n    }\n\n    const size = textLabelSize + trendLabelSize - LABEL_PADDING;\n\n    const label = {\n        text: barLabel,\n        size,\n        trend: trendData != null\n            ? {\n                compareValue: trendData.compareValue,\n                isPositive: trendData.isPositive,\n            }\n            : undefined,\n    };\n\n    const isNegativeBar = sum(values) < 0;\n    const labels = getLabels({\n        headLabel: label,\n        isNegativeBar,\n    });\n\n    const result = ComponentWithLabel({\n        component: simpleBar,\n        contentWidth: percentageTotal,\n        labels,\n        position: isNegativeBar ? 'left' : 'right',\n        centerComponent: type === 'bar' && isNegativeMin && !isNegativeMax,\n        isAllPositive: !isNegativeMin && !isNegativeMax,\n    });\n\n    const width = `calc(100% - ${ trendData != null ? size : size * labelCount}px)`;\n\n    result.style.setProperty('width', width);\n    result.style.setProperty('margin-left', `${\n        computeLeftMargin({\n            min: minValue,\n            max: maxValue,\n            headLabelSize: size,\n        })\n    }`);\n\n    return result;\n};\n","import './CompareBarCell.scss';\n\nimport tinycolor from '@ctrl/tinycolor';\nimport html from 'nanohtml';\n\nimport {\n    BLUE,\n    CONTRAST_ALPHA,\n    GTR_BAR_CLASS,\n    GTR_COMPARE_BAR_CELL_CLASS,\n    GTR_COMPARE_BAR_CLASS,\n    GTR_COMPARE_BAR_CONTAINER_CLASS,\n} from '../../../common/constants';\nimport { assert } from '../../../common/util/assert';\nimport { Trend } from '../../common/models/Trend';\nimport { Bar } from '../components/Bar';\nimport { ComponentWithLabel } from '../components/ComponentWithLabel';\nimport { TrendBounds } from '../models/ColumnWithTrend';\nimport { getMaxLabelSize } from '../util';\nimport { getLabels } from '../util/getLabels';\nimport { limitBelowEpsilon } from '../util/limitBelowEpsilon';\nimport {\n    computeLabelCount,\n    computeLeftMargin,\n    computeLeftZeroLine,\n    computePercentageTotal,\n    computeWidthDenominator,\n    computeWidthPositiveNumbers,\n} from './common';\nimport { ZeroLine } from './ZeroLine';\n\nexport type CompareBarCellData = {\n    current: number;\n    previous: number;\n    currentLabel: string;\n    previousLabel: string;\n    trend?: Trend;\n};\n\ntype CompareBarCellProps = {\n    data: CompareBarCellData;\n    backgroundColor?: string;\n    compareBackgroundColor?: string;\n    max: number;\n    min: number;\n    trendBounds?: TrendBounds;\n};\n\nexport const CompareBarCell = ({\n    data,\n    max,\n    min,\n    trendBounds,\n    backgroundColor = BLUE,\n    compareBackgroundColor,\n}: CompareBarCellProps) => {\n    const {\n        current: currentRaw,\n        previous: previousRaw,\n        trend: trendData,\n    } = data;\n\n    const isNegativeMin = min < 0;\n    const isNegativeMax = max < 0;\n\n    const widthDenominator = computeWidthDenominator({\n        min,\n        max,\n    });\n\n    const widthPositiveNumbers = computeWidthPositiveNumbers({\n        min,\n        widthDenominator,\n    });\n\n    const maxAbsolute = Math.max(Math.abs(min), max);\n\n    const current = limitBelowEpsilon(currentRaw, maxAbsolute);\n    const previous = limitBelowEpsilon(previousRaw, maxAbsolute);\n\n    assert(\n        maxAbsolute >= current && maxAbsolute >= previous,\n        `Maximum (${maxAbsolute}) cannot be lower than bar current (${current}) or previous (${previous}).`,\n    );\n\n    const compare = {\n        backgroundColor: compareBackgroundColor ?? tinycolor(backgroundColor)\n            .setAlpha(CONTRAST_ALPHA)\n            .toRgbString(),\n        width: Math.abs(previous) / widthDenominator * 100,\n    };\n\n    const bar = {\n        width: Math.abs(current) / widthDenominator * 100,\n        backgroundColor,\n    };\n\n    const currentBar = Bar({\n        value: current,\n        min,\n        max,\n        color: bar.backgroundColor,\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_BAR_CLASS,\n    });\n\n    const compareBar = Bar({\n        value: previous,\n        min,\n        max,\n        color: compare.backgroundColor,\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_COMPARE_BAR_CLASS,\n    });\n\n    const leftZeroLine = computeLeftZeroLine({\n        min,\n        max,\n        widthPositiveNumbers,\n    });\n\n    const zeroLine = ZeroLine({\n        left: `${leftZeroLine}`,\n        display: isNegativeMin,\n    });\n\n    const biggestPositive = current < 0 && previous < 0 ? Math.min(current, previous) : Math.max(current, previous);\n    const percentageTotal = computePercentageTotal({\n        min,\n        values: [ biggestPositive ],\n        widthDenominator,\n    });\n\n    const compareAndCurrentBar = html`\n    <div class=\"${GTR_COMPARE_BAR_CELL_CLASS}\">\n        ${zeroLine}\n        <div class=\"${GTR_COMPARE_BAR_CONTAINER_CLASS}\">\n            ${currentBar}\n            ${compareBar}\n        </div>\n    </div>\n    ` as HTMLDivElement;\n\n    const trendLabelSize = trendBounds != null\n        ? getMaxLabelSize(trendBounds.min, trendBounds.max) + 14\n        : 0;\n\n    const label = trendData != null\n        ? {\n            text: '',\n            size: trendLabelSize,\n            trend: {\n                compareValue: trendData.compareValue,\n                isPositive: trendData.isPositive,\n            },\n        }\n        : undefined;\n\n    const result = ComponentWithLabel({\n        component: compareAndCurrentBar,\n        contentWidth: percentageTotal,\n        labels: getLabels({\n            headLabel: label,\n            isNegativeBar: biggestPositive < 0,\n        }),\n        position: biggestPositive < 0 ? 'left' : 'right',\n        isAllPositive: !isNegativeMax && !isNegativeMin,\n    });\n\n    const labelCount = computeLabelCount({\n        min,\n        max,\n    });\n\n    const width = `calc(100% - ${ trendLabelSize * labelCount}px)`;\n    const margin = `${isNegativeMin && !isNegativeMax ? '0 auto' : 'initial'}`;\n\n    result.style.setProperty('width', width);\n    result.style.setProperty('margin', margin);\n    result.style.setProperty('margin-left', `${\n        computeLeftMargin({\n            min,\n            max,\n            headLabelSize: trendLabelSize,\n        })\n    }`);\n\n    return result;\n};\n","import './HeaderCell.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_HEADER_CELL_CLASS,\n    GTR_SORT_NONE,\n    GTR_SORTABLE,\n    TextAlignment,\n} from '../../../common/constants';\nimport { AlignedLabel } from '../components/AlignedLabel';\nimport { SortIcon } from '../components/sorting/SortIcon';\n\nconst SORT_CLASS = `${ GTR_SORTABLE } ${ GTR_SORT_NONE }`;\n\ntype HeaderCellProps = {\n    label: string;\n    style?: string;\n    align?: TextAlignment;\n    isSortable?: boolean;\n};\n\nconst wrapHeaderElement = (element: HTMLElement, align: TextAlignment) => html`\n        <div role=\"button\"\n            style=\"width:100%; display: flex; gap: 8px; justify-content: ${align === 'right' ? 'flex-end' : 'flex-start'}\"\n        >\n            <div style=\"min-width: 0;\">\n                ${element}\n            </div>\n            ${SortIcon()}\n        </div>\n    `;\n\nexport const HeaderCell = ({\n    label,\n    align = 'left',\n    style = '',\n    isSortable = false,\n}: HeaderCellProps) => {\n    const headerCellClass = clsx(\n        GTR_HEADER_CELL_CLASS,\n        isSortable && SORT_CLASS\n    );\n\n    const headerLabel = AlignedLabel({\n        label,\n        align,\n    });\n\n    // TODO DNA-923: add translations to DUF\n    const sortLabel = `Sort column ${label}`;\n\n    const headerContent = isSortable\n        ? wrapHeaderElement(headerLabel, align)\n        : headerLabel;\n\n    const headerCell = html`\n        <div class=\"${headerCellClass}\"\n             role=\"${'columnheader'}\"\n             style=\"${style}\"\n             tabindex=\"-1\"\n        >\n            ${headerContent}\n        </div>\n    ` as HTMLDivElement;\n\n    if (isSortable) {\n        headerCell.setAttribute('tabindex', '0');\n        headerCell.setAttribute('aria-label', sortLabel);\n    }\n\n    return headerCell;\n};\n","import html from 'nanohtml';\n\nexport const SortIcon = () => html`\n    <svg xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 8 16\"\n        class=\"sort-icon\">\n        <path class=\"path-asc\"\n            d=\"M0,6.66667 L4,2.66667 L8,6.66667 Z\" />\n        <path class=\"path-desc\"\n            d=\"M0,9.33333 L4,13.3333 L8,9.33333 Z\" />\n    </svg>\n`;\n","import './TableHeader.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_HEADER_CELL_ACTION_CLASS,\n    GTR_HEADER_CELL_WRAPPER_CLASS,\n    GTR_HEADER_CLASS,\n    GTR_ROW_CLASS,\n} from '../../../common/constants';\nimport { Column } from '../models';\nimport { HeaderCell } from '../renderers/HeaderCell';\nimport { rowMinWidth } from '../util';\nimport { getColumnAlignment } from '../util/getColumnAlignment';\n\nconst createHeaderCells = <TRowData, TChartMeta>(\n    columns: Array<Column<TRowData, TChartMeta>>\n) => columns.map(\n    (column, columnIndex) => {\n        const isColumnSortable = column.sortable ?? false;\n        const align = getColumnAlignment(column);\n\n        const headerCellWidth = align === 'right'\n            ? 'fit-content'\n            : 'calc(100% - 24px)';\n\n        const headerCell = HeaderCell({\n            label: column.name,\n            align,\n            style: `\n                    width: ${column.action ? headerCellWidth : '100%'};\n                `,\n            isSortable: isColumnSortable,\n        });\n\n        headerCell.setAttribute('aria-sort', 'none');\n        headerCell.dataset.columnIndex = columnIndex.toString();\n        headerCell.dataset.tooltipContent = column.tooltipContent ?? column.name;\n\n        const actionElement = column.action\n            ? html`<div\n                role=\"button\"\n                tabindex=\"0\"\n                class=\"${GTR_HEADER_CELL_ACTION_CLASS}\"\n                data-tooltip-content=\"${column.action.tooltip}\"\n                data-columnindex=\"${columnIndex}\"\n            >\n                ${column.action.icon}\n            </div>`\n            : undefined;\n\n        const wrapperStyle = `\n            justify-content: ${align === 'right' ? 'flex-end' : 'flex-start'};\n            width: ${column.size}%;\n        `;\n\n        return html`\n            <div class=\"${GTR_HEADER_CELL_WRAPPER_CLASS}\"\n                style=\"${wrapperStyle}\"\n            >\n                ${actionElement}\n                ${headerCell}\n            </div>\n        `;\n    });\n\nexport const TableHeader = <TRowData, TChartMeta>(\n    columns: Array<Column<TRowData, TChartMeta>>,\n): HTMLDivElement => html`\n        <div class=\"${GTR_ROW_CLASS} ${GTR_HEADER_CLASS}\"\n             style=\"min-width: ${rowMinWidth(columns)}px;\"\n             data-state=\"loaded\"\n             role=\"row\">\n             ${createHeaderCells(columns)}\n        </div>\n    ` as HTMLDivElement;\n","import { __extends } from \"tslib\";\nimport { Subject } from './Subject';\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, (this._value = value));\n    };\n    return BehaviorSubject;\n}(Subject));\nexport { BehaviorSubject };\n//# sourceMappingURL=BehaviorSubject.js.map","import clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_CELL_CLASS,\n    GTR_CELL_RESIZING_CLASS,\n} from '../../../common/constants';\nimport { assert } from '../../../common/util';\nimport { InteractiveColumn } from '../models';\n\ninterface ContentCellProperties<TRowData, TMetaData> {\n    column: InteractiveColumn<TRowData, TMetaData>;\n    className?: string;\n    rowIndex?: number;\n    columnIndex?: number;\n    hasRowHeader?: boolean;\n}\n\nexport const ContentCell = <TRowData, TMetaData>({\n    column,\n    className,\n    rowIndex = -1,\n    columnIndex = -1,\n    hasRowHeader = false,\n}: ContentCellProperties<TRowData, TMetaData>) => {\n    assert(!hasRowHeader || columnIndex >= 0, 'Column index must be larger than -1 when using row headers.');\n\n    return html`\n        <div class=\"${clsx(GTR_CELL_CLASS, column.isResizing ? GTR_CELL_RESIZING_CLASS : undefined, className)}\"\n            role=${hasRowHeader && columnIndex === 0 ? 'rowheader' : 'cell'}\n            style=\"\n                width: ${column.size}%;\n                min-width: ${column.minWidth ?? 0}px;\n            \"\n            data-type=\"${column.type}\"\n            data-row-index=\"${rowIndex}\"\n            data-column-index=\"${columnIndex}\"\n        >\n        </div>\n    `;\n};\n","import clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_EVEN_CLASS,\n    GTR_ODD_CLASS,\n    GTR_ROW_CLASS,\n} from '../../../common/constants';\nimport { RowState } from '../models';\n\ninterface RowProperties {\n    index: number;\n    state: RowState;\n    minWidth: number;\n    height: number;\n    className?: string;\n}\n\nexport const TableRow = ({\n    index,\n    state,\n    minWidth,\n    height,\n    className,\n}: RowProperties) => {\n    const rowParityClass = index % 2 === 0\n        ? GTR_ODD_CLASS\n        : GTR_EVEN_CLASS;\n\n    const rowClass = clsx(\n        GTR_ROW_CLASS,\n        rowParityClass,\n        className,\n    );\n\n    return html`\n        <div class=\"${rowClass}\"\n                role=\"row\"\n                data-state=${state}\n                aria-rowindex=\"${index}\"\n                style=\"\n                    height: ${height}px;\n                    min-width: ${minWidth}px;\n                \"\n        >\n        </div>\n    ` as HTMLDivElement;\n};\n","import './GenericRowRenderer.scss';\n\nimport clsx from 'clsx';\n\nimport {\n    GTR_SELECTED_COLUMN_CLASS,\n    GTR_SELECTED_ROW_CELL_CLASS,\n    GTR_SELECTED_ROW_CLASS,\n} from '../../../../common/constants';\nimport {\n    Column,\n    RowState,\n    SelectableElement,\n    SelectableElementType,\n} from '../../models';\nimport { CellFactory } from '../../renderers';\nimport { rowMinWidth } from '../../util';\nimport { ContentCell } from '../ContentCell';\nimport { TableRow } from '../TableRow';\n\ninterface GenericRowRendererProps<TRowData, TMetaData> {\n    columns: Array<Column<TRowData, TMetaData>>;\n    isSelected?: (selectableElement: SelectableElement<TRowData>) => boolean;\n    isSelecting?: () => boolean;\n    onRowUpdate?: (index: number, data: TRowData) => void;\n    hasRowHeader?: boolean;\n}\n\nexport class GenericRowRenderer<TRowData, TMetaData> {\n    get itemHeight() {\n        return this._itemHeight;\n    }\n\n    private _hasRowHeader: boolean;\n    private _itemHeight: number;\n    private _columns: Array<Column<TRowData, TMetaData>>;\n    private _isSelected: (selectableElement: SelectableElement<TRowData>) => boolean;\n    private _isSelecting: () => boolean;\n    private _onRowUpdate?: (index: number, data: TRowData) => void;\n\n    constructor({\n        columns,\n        isSelected = () => false,\n        isSelecting = () => false,\n        onRowUpdate,\n        hasRowHeader = false,\n    }: GenericRowRendererProps<TRowData, TMetaData>) {\n        this._columns = columns;\n        this._isSelected = isSelected;\n        this._isSelecting = isSelecting;\n        this._onRowUpdate = onRowUpdate;\n        this._hasRowHeader = hasRowHeader;\n\n        this._itemHeight = this._columns.reduce(current => Math.max(current, 40), 0);\n    }\n\n    renderRow(\n        virtualEntryIndex: number,\n        entryIndex: number,\n        rowData: TRowData,\n    ): HTMLDivElement {\n        const row = this.createRow(virtualEntryIndex, RowState.loaded, rowData);\n\n        this._columns\n            .map((column, cIndex) => this._renderCell(\n                rowData,\n                column,\n                cIndex,\n                virtualEntryIndex,\n                entryIndex,\n            ))\n            .forEach(cell => row.appendChild(cell));\n\n        this._onRowUpdate?.(entryIndex, rowData);\n        return row;\n    }\n\n    createRow(virtualEntryIndex: number, rowState: RowState, data: TRowData | undefined) {\n        const className = clsx(\n            this._isSelectedRow(virtualEntryIndex, data) && GTR_SELECTED_ROW_CLASS\n        );\n\n        return TableRow({\n            index: virtualEntryIndex + 1,\n            state: rowState,\n            minWidth: rowMinWidth(this._columns),\n            height: this.itemHeight,\n            className,\n        });\n    }\n\n    private _isSelectedRow(virtualEntryIndex: number, data: TRowData | undefined) {\n        return this._isSelected({\n            type: 'row',\n            index: virtualEntryIndex,\n            data,\n        });\n    }\n\n    private _renderCell(\n        rowData: TRowData,\n        column: Column<TRowData, TMetaData>,\n        columnIndex: number,\n        rowIndex: number,\n        entryIndex: number,\n    ) {\n        const cell = ContentCell({\n            column,\n            columnIndex,\n            rowIndex: entryIndex,\n            className: this._getCellSelectionClass(columnIndex),\n            hasRowHeader: this._hasRowHeader,\n        });\n\n        const cellContent = CellFactory({\n            rowIndex,\n            columnIndex,\n            column,\n            rowData,\n            isSelecting: this._isSelecting,\n        });\n\n        cell.appendChild(cellContent);\n        return cell;\n    }\n\n    private _getCellSelectionClass(columnIndex: number) {\n        const isInSelection = (type: SelectableElementType) => this._isSelected({\n            type,\n            index: columnIndex,\n        });\n\n        return clsx(\n            isInSelection('column') && GTR_SELECTED_COLUMN_CLASS,\n            isInSelection('rowCell') && GTR_SELECTED_ROW_CELL_CLASS\n        );\n    }\n}\n","import html from 'nanohtml';\n\nimport { DUF_CUSTOM_SCROLLBAR_CLASS } from '../../../common/constants';\n\nexport function scrollbarWidth(isCustomScrollbar: boolean = true) {\n    const wrapperClass = isCustomScrollbar ? DUF_CUSTOM_SCROLLBAR_CLASS : '';\n    const wrapper = html`\n        <div class=${wrapperClass}\n            style=\"\n                position: absolute;\n                top: -99999999px;\n                overflow-y: scroll;\n        \">\n        </div>\n    `;\n\n    document.body.appendChild(wrapper);\n    const scrollbarWidthValue = wrapper.offsetWidth - wrapper.clientWidth;\n    wrapper.remove();\n\n    return scrollbarWidthValue;\n}\n","import './GenericTableRenderer.scss';\n\nimport { InfinityList } from '@uipath/infinity';\nimport clsx from 'clsx';\nimport sum from 'lodash-es/sum';\nimport html from 'nanohtml';\nimport {\n    merge,\n    Subject,\n} from 'rxjs';\nimport {\n    distinctUntilChanged,\n    map,\n    share,\n    takeUntil,\n    tap,\n} from 'rxjs/operators';\nimport Split from 'split.js';\nimport {\n    delegate,\n    DelegateInstance,\n    hideAll,\n    Instance,\n} from 'tippy.js';\n\nimport {\n    DUF_CUSTOM_SCROLLBAR_CLASS,\n    GTR_CELL_SELECTOR,\n    GTR_GANTT_FOCUS_CLASS,\n    GTR_GANTT_FOCUS_SELECTOR,\n    GTR_HEADER_CELL_ACTION_SELECTOR,\n    GTR_HEADER_CELL_SELECTOR,\n    GTR_HEADER_CELL_WRAPPER_SELECTOR,\n    GTR_SELECTED_COLUMN_CLASS,\n    GTR_SELECTED_ROW_CELL_CLASS,\n    GTR_SELECTED_ROW_CLASS,\n    GTR_TABLE_CLASS,\n    GTR_VIEWPORT_CLASS,\n    GTR_VIEWPORT_SCROLL_VISIBLE,\n    GTR_WITH_FOOTER_CLASS,\n} from '../../common/constants';\nimport { DEFAULT_TIPPY_PROPERTIES } from '../../common/constants/defaultTippyProperties';\nimport { assert } from '../../common/util/assert';\nimport { ElementResizeObserver } from '../../common/util/ElementResizeObserver';\nimport { ComponentType } from '../../plugins/message-handler';\nimport { MessageHandler } from '../../plugins/message-handler/MessageHandler';\nimport { MessageStatus } from '../../plugins/message-handler/models/MessageStatus';\nimport {\n    AsynchronousRowRenderer,\n    Selector,\n    SynchronousRowRenderer,\n    TableFooter,\n    TableHeader,\n} from './components';\nimport { ActionManager } from './components/ActionManager';\nimport { clearSelection } from './components/selection/util';\nimport { SortManager } from './components/sorting';\nimport {\n    GenericTableRendererOptions,\n    InteractiveColumn,\n    SelectableElement,\n} from './models';\nimport {\n    SelectionEvent,\n    SelectionState,\n    ValueSelection,\n} from './models/SelectionState';\nimport { TooltipFactory } from './tooltips';\nimport {\n    isScrollVisible,\n    onHorizontalScroll,\n    onScroll,\n    scrollbarWidth,\n    ScrollInfo,\n} from './util';\nimport { createResizeGutter } from './util/createResizeGutter';\nimport { endColumnResize } from './util/endColumnResize';\nimport { mapColumnToMinSize } from './util/mapColumnToMinSize';\nimport { resizeColumns } from './util/resizeColumns';\n\nexport const GUTTER_SIZE = 20;\n\nexport class GenericTableRenderer<TRowData, TMetaData> {\n    get viewport() {\n        return this._viewport;\n    }\n\n    private _header: HTMLDivElement;\n    private _footer?: HTMLDivElement;\n    private _viewport: HTMLDivElement;\n    private _table: HTMLDivElement;\n    private _infinity: InfinityList;\n    private _renderer: AsynchronousRowRenderer<TRowData, TMetaData> | SynchronousRowRenderer<TRowData, TMetaData>;\n\n    private _destroyed$ = new Subject<void>();\n    private _selector: Selector<TRowData>;\n    private _tooltip: DelegateInstance;\n    private _sorting?: SortManager;\n    private _rows = new Map<number, TRowData>();\n    private _columns: Array<InteractiveColumn<TRowData, TMetaData>>;\n    private _scrollBarWidth: number;\n    private _actionManager: ActionManager<TRowData, TMetaData>;\n    private _messageHandler: MessageHandler;\n    private _splitInstance: Split.Instance;\n\n    private _onSelectCallback?: (selection: SelectionEvent<TRowData>) => void;\n    private _isSelected?: (selectableElement: SelectableElement<TRowData>) => boolean;\n    private _activeSelection: 'row' | 'column' | 'none';\n\n    constructor(\n        parent: HTMLElement,\n        options: GenericTableRendererOptions<TRowData, TMetaData>,\n    ) {\n        this._scrollBarWidth = scrollbarWidth();\n\n        const {\n            columns,\n            dataset,\n            onSelect,\n            onSort,\n            isSelected = () => false,\n            initialSort,\n            messageMapper,\n        } = options;\n\n        const dataSize = dataset.type === 'sync'\n            ? dataset.data.length\n            : dataset.dataSize\n        ;\n        const hasData = dataSize > 0;\n\n        const totalSize = sum(columns.map(c => c.size));\n        if (totalSize > 100) {\n            throw Error('The sum of all columns can be at most 100%');\n        }\n\n        this._columns = columns;\n        const isFooterVisible = hasData && columns\n            .some((column) => column.footer != null);\n\n        this._header = TableHeader(columns);\n        this._viewport = this._createViewport({\n            isFooterVisible,\n            ...options,\n        });\n        this._footer = TableFooter({\n            columns,\n            isVisible: isFooterVisible,\n        });\n\n        this._table = html`\n            <div class=\"${GTR_TABLE_CLASS}\"\n                 role=\"table\"\n                 aria-rowcount=\"${dataSize}\"\n            >\n                 ${this._header}\n                 ${this._viewport}\n                 ${this._footer}\n            </div>\n        ` as HTMLDivElement;\n\n        parent.appendChild(this._table);\n\n        const hasBarColumn = columns.some(c => c.type === 'bar');\n        const componentType = hasBarColumn\n            ? ComponentType.HorizontalBarChart\n            : ComponentType.Table;\n\n        this._messageHandler = new MessageHandler(this._viewport, messageMapper);\n        this._messageHandler.update(!hasData ? MessageStatus.NoData : undefined, componentType);\n\n        const isSelectionEnabled = onSelect != null;\n\n        this._selector = new Selector({ viewport: this._table });\n\n        this._activeSelection = 'none';\n        this._isSelected = isSelected;\n\n        this._actionManager = new ActionManager({\n            columns,\n            target: this._header,\n        });\n\n        if (isSelectionEnabled) {\n            this._onSelectCallback = onSelect;\n            this._selector.select$.subscribe(this._onSelect);\n            this._selector.activate();\n        }\n\n        const isSortable = columns.some(column => column.sortable);\n        if (isSortable) {\n            this._sorting = new SortManager({\n                target: this._header,\n                state: initialSort,\n                onUpdate: (state) => {\n                    onSort?.(state);\n                },\n                isSelecting: () => this._activeSelection === 'column',\n            });\n        }\n\n        this._renderer = this._createRenderer(options);\n        this._infinity = this._createInfinity(dataSize);\n\n        this._tooltip = delegate(this._table, {\n            ...DEFAULT_TIPPY_PROPERTIES,\n            onShow: this._onTooltipShow,\n            target: `${GTR_HEADER_CELL_SELECTOR}, ${GTR_CELL_SELECTOR}, ${GTR_GANTT_FOCUS_SELECTOR}, ${GTR_HEADER_CELL_ACTION_SELECTOR}`,\n        });\n\n        ElementResizeObserver.Instance\n            .observe(this._viewport)\n            .pipe(\n                map(entry => isScrollVisible(entry.target)),\n                distinctUntilChanged(),\n            )\n            .subscribe(this._onScrollVisibilityChange);\n\n        const headers = this._table.querySelectorAll<HTMLElement>(GTR_HEADER_CELL_WRAPPER_SELECTOR);\n        const sizes = this._columns.map(column => column.size);\n        const minSizes = this._columns.map((column, index) => index === 0\n            ? mapColumnToMinSize(column)\n            : mapColumnToMinSize(column) - GUTTER_SIZE\n        );\n\n        this._splitInstance = Split(Array.from(headers), {\n            snapOffset: 0,\n            sizes,\n            minSize: minSizes,\n            onDrag: (updatedSizes: number[]) => {\n                resizeColumns({\n                    updatedSizes,\n                    columns: this._columns,\n                    table: this._table,\n                });\n                this._infinity.render(true);\n            },\n            onDragEnd: () => endColumnResize(this._table, this._columns),\n            gutterSize: GUTTER_SIZE,\n            gutter: (index) => createResizeGutter(index, this._columns),\n        });\n    }\n\n    destroy() {\n        this._destroyed$.next();\n\n        this._tooltip.destroy();\n        this._selector.destroy();\n        this._infinity.destroy();\n        this._sorting?.destroy();\n        this._messageHandler.destroy();\n        this._actionManager.destroy();\n\n        this._table.remove();\n        this._rows.clear();\n        this._splitInstance.destroy(true, true);\n\n        ElementResizeObserver.Instance.unobserve(this._viewport);\n    }\n\n    setHorizontalScroll(left: number) {\n        this._viewport.scrollLeft = left;\n        this._setHorizontalMargins({ left });\n    }\n\n    setSelection(selection: SelectionState) {\n        clearSelection(this._table);\n\n        const indices = selection.type === 'index'\n            ? selection.indices\n            : this._getIndicesFromValues(selection);\n\n        const isRowSelection = selection.type === 'index'\n            ? selection.isRowSelection\n            : true;\n\n        const selectionType = isRowSelection ? 'row' : 'column';\n\n        this._activeSelection = indices.length > 0\n            ? selectionType\n            : 'none';\n\n        isRowSelection\n            ? this._setRowSelection(indices, selection.rowCell)\n            : this._setColumnSelection(indices);\n    }\n\n    private _setColumnSelection = (indices: number[]) => {\n        indices.forEach((columnIndex) => {\n            const columnHeader = this._table.querySelector(`.gtr-header-cell[data-column-index='${columnIndex}']`);\n            const columnCell = this._table.querySelectorAll(`.gtr-cell[data-column-index='${columnIndex}']`);\n\n            if (columnHeader == null || columnCell == null) {\n                return;\n            }\n\n            columnHeader.classList.add(GTR_SELECTED_COLUMN_CLASS);\n            columnCell.forEach(node => node.classList.add(GTR_SELECTED_COLUMN_CLASS));\n        });\n    };\n\n    private _setRowSelection = (indices: number[], rowCell: number | null) => {\n        indices.forEach((rowIndex) => {\n            const row = this._table.querySelector(`.gtr-row[data-infinity-id='${rowIndex}']`);\n\n            if (row == null) {\n                return;\n            }\n\n            row.classList.add(GTR_SELECTED_ROW_CLASS);\n        });\n\n        if (rowCell == null) {\n            return;\n        }\n\n        const rowCells = this._table.querySelectorAll(`.gtr-cell[data-column-index='${rowCell}']`);\n\n        rowCells.forEach(node => node.classList.add(GTR_SELECTED_ROW_CELL_CLASS));\n    };\n\n    private _getIndicesFromValues({\n        rowCell,\n        values,\n    }: ValueSelection) {\n        const [ start, end ] = this._infinity.range;\n        const length = end - start; // exclude the table header row\n        const visibleRowsData = this._renderer.cachedData(Array.from({ length }, (_, idx) => start + idx));\n        const column = this._columns[rowCell];\n        const newIndices: number[] = [];\n\n        assert(column.type === 'text', `Cannot map values from column type ${column.type} to indices`);\n        visibleRowsData.forEach((visibleRowData, idx) => {\n            if (visibleRowData == null) {\n                return;\n            }\n\n            const mappedCell = column.mapper(visibleRowData);\n            const isSelected = values\n                .some(rowCellValue => rowCellValue === (typeof mappedCell === 'string'\n                    ? mappedCell\n                    : mappedCell.value\n                ));\n\n            if (isSelected) {\n                newIndices.push(start + idx);\n            }\n        });\n\n        return newIndices;\n    }\n\n    private _onScrollVisibilityChange = (isScrollBarVisible: boolean) => {\n        const padding = isScrollBarVisible ? this._scrollBarWidth : 0;\n        const scrollBarClasses = [ GTR_VIEWPORT_SCROLL_VISIBLE, DUF_CUSTOM_SCROLLBAR_CLASS ];\n\n        if (isScrollBarVisible) {\n            this._viewport.classList.add(...scrollBarClasses);\n        } else {\n            this._viewport.classList.remove(...scrollBarClasses);\n        }\n\n        const setPadding = (element: HTMLDivElement | undefined) => {\n            element?.style?.setProperty?.('padding-right', `${ padding }px`);\n        };\n\n        setPadding(this._footer);\n        setPadding(this._header);\n    };\n\n    private _onSelect = (selection: SelectionEvent<TRowData>) => {\n        const hasSelection = selection.indices.length > 0;\n        if (!selection.isRowSelection || !hasSelection) {\n            this._onSelectCallback?.(selection);\n            return;\n        }\n\n        const data = this._renderer.cachedData(selection.indices);\n        const hasUndefined = data.some((value) => value == null);\n        assert(!hasUndefined, 'Selection contained undefined data');\n        this._onSelectCallback?.({\n            ...selection,\n            rowData: data as TRowData[],\n        });\n    };\n\n    private _createViewport({\n        isFooterVisible,\n        onScrollHorizontal,\n    }: GenericTableRendererOptions<TRowData, TMetaData> & { isFooterVisible: boolean }) {\n        const viewPortClass = clsx(\n            GTR_VIEWPORT_CLASS,\n            isFooterVisible && GTR_WITH_FOOTER_CLASS,\n        );\n\n        const viewport = html`\n            <div class=\"${viewPortClass}\" tabindex=\"-1\">\n            </div>\n        ` as HTMLDivElement;\n\n        const scroll$ = onScroll(viewport)\n            .pipe(share());\n\n        const hideTooltip$ = scroll$\n            .pipe(tap(() => {\n                hideAll({ duration: 0 });\n            }));\n\n        const scrollMargin$ = onHorizontalScroll(scroll$)\n            .pipe(\n                tap(info => onScrollHorizontal?.(info)),\n                tap(this._setHorizontalMargins),\n            );\n\n        merge(\n            hideTooltip$,\n            scrollMargin$,\n        )\n            .pipe(takeUntil(this._destroyed$))\n            .subscribe();\n\n        return viewport;\n    }\n\n    private _createRenderer(options: GenericTableRendererOptions<TRowData, TMetaData>) {\n        const rowRendererOptions = {\n            isSelected: this._isSelected,\n            isSelecting: () => this._activeSelection !== 'none',\n            columns: options.columns,\n            onRowUpdate: (index: number, data: TRowData) => this._rows.set(index, data),\n            onChartRender: options.onChartRender,\n            hasRowHeader: options.hasRowHeader,\n        };\n\n        const { dataset } = options;\n        if (dataset.type === 'sync') {\n            return new SynchronousRowRenderer({\n                data: dataset.data,\n                ...rowRendererOptions,\n            });\n        }\n\n        return new AsynchronousRowRenderer({\n            dataSource: (range) => dataset.fetchData(range),\n            ...rowRendererOptions,\n        });\n    }\n\n    private _createInfinity(dataSize: number) {\n        return new InfinityList(this._viewport, {\n            count: dataSize,\n            overscan: 5,\n            renderer: this._renderer,\n        });\n    }\n\n    private _setHorizontalMargins = ({ left }: Pick<ScrollInfo, 'left'>) => {\n        const setMargin = (element: HTMLDivElement | undefined) => {\n            element?.style?.setProperty('margin-left', `-${left}px`);\n        };\n\n        setMargin(this._footer);\n        setMargin(this._header);\n    };\n\n    private _onTooltipShow = (instance: Instance): void | false => {\n        const element = instance.reference;\n        assert(element instanceof HTMLElement, 'Invalid tooltip target');\n\n        const { tooltipContent } = element.dataset;\n\n        const result = tooltipContent != null\n            ? tooltipContent\n            : this._cellTooltip(element);\n\n        if (!result) {\n            return false;\n        }\n\n        instance.setContent(result);\n    };\n\n    private _cellTooltip = (element: HTMLElement) => {\n        const isGanttFocus = element.classList.contains(GTR_GANTT_FOCUS_CLASS);\n\n        const target = isGanttFocus\n            ? element.closest<HTMLDivElement>(GTR_CELL_SELECTOR)\n            : element;\n\n        assert(target != null, 'Expected the target to exist');\n\n        const {\n            columnIndex,\n            rowIndex,\n        } = target.dataset;\n        if (columnIndex == null || rowIndex == null) {\n            return false;\n        }\n\n        const column = this._columns[\n            Number.parseInt(columnIndex, 10)\n        ];\n        const rowData = this._rows.get(\n            Number.parseInt(rowIndex, 10),\n        );\n\n        const isGanttCell = column?.type === 'gantt-chart';\n        if (rowData == null || (isGanttCell && !isGanttFocus)) {\n            return false;\n        }\n\n        return TooltipFactory<TRowData, TMetaData>({\n            column,\n            rowData,\n        });\n    };\n}\n","import './TableFooter.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_CELL_CLASS,\n    GTR_FOOTER_CLASS,\n    GTR_ROW_CLASS,\n} from '../../../common/constants';\nimport { Column } from '../models';\nimport { TextCell } from '../renderers';\nimport { rowMinWidth } from '../util';\nimport { getColumnAlignment } from '../util/getColumnAlignment';\n\ntype TableFooterProps<TRowData, TMetaData> = {\n    columns: Array<Column<TRowData, TMetaData>>;\n    isVisible: boolean;\n};\n\nexport const TableFooter = <TRowData, TMetaData>({\n    columns,\n    isVisible,\n}: TableFooterProps<TRowData, TMetaData>) => {\n    const footerCells = columns\n        .map(column =>\n            TextCell({\n                data: column.footer ?? '',\n                style: `\n                    width: ${ column.size }%;\n                    min-width: ${ column.minWidth ?? 0}px;\n                `,\n                className: GTR_CELL_CLASS,\n                align: getColumnAlignment(column),\n            }),\n        );\n\n    return html`\n        <div class=\"${GTR_ROW_CLASS} ${GTR_FOOTER_CLASS}\"\n             style=\"\n                    min-width: ${rowMinWidth(columns)};\n                    display: ${isVisible ? '' : 'none'}\n            \"\n             data-state=\"loaded\">\n                ${\n    footerCells\n}\n        </div>\n    ` as HTMLDivElement;\n};\n"],"names":[],"sourceRoot":""}